# -*- coding: utf-8 -*-
"""main1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19mP4DLfznBmfdAbaR4zfLVBvmdL-2_Au
"""

import pandas as pd

data = pd.read_csv('PraxisDataset1.csv')

data

import missingno as mnso
import matplotlib.pyplot as plt
mnso.matrix(data)

print(data.columns.values.tolist())

# Define category mapping
class_mapping = {
    'Benign': 0,
    'Brute Force': 1,
    'DDoS': 2,
    'MITM': 3,
    'SQL Injection': 4
}
# Add new integer category column
data['attack type'] = data['attack type'].map(class_mapping)
print(data['attack type'])

from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
import pandas as pd
from sklearn.preprocessing import LabelEncoder
from sklearn.impute import KNNImputer
# Define category mapping
# class_mapping = {
#     'benign': 0,
#     'Brute Force': 1,
#     'DDoS': 2,
#     'MITM': 3,
#     'SQL Injection': 4
# }
# Add new integer category column
# data['attack type'] = data['attack type'].map(class_mapping)
# Recode character data to numeric
label_encoders = {}
for column in data.select_dtypes(include=['object']).columns:
    le = LabelEncoder()
    data[column] = le.fit_transform(data[column])
    label_encoders[column] = le

# Separate missing values
data_with_nan = data[data['jitter'].isna()]
data_without_nan = data.dropna(subset=['jitter'])

# target variables
X = data_without_nan.drop('jitter', axis=1)
y = data_without_nan['jitter']

# Split train set and test set
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train RF Regressor model
rf = RandomForestRegressor(n_estimators=100, random_state=42)
rf.fit(X_train, y_train)

# Predicting missing values
data_with_nan['jitter'] = rf.predict(data_with_nan.drop('jitter', axis=1))

# Data consolidation
data_imputed = pd.concat([data_without_nan, data_with_nan]).sort_index()

# Save imputed data to data_imputed.csv
data_imputed.to_csv('data_imputed.csv', index=False)

data = pd.read_csv('data_imputed.csv')
import missingno as mnso
import matplotlib.pyplot as plt
mnso.matrix(data)

import joblib
from itertools import cycle
import numpy as np
from sklearn.linear_model import LogisticRegression
import pandas as pd
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier
from lightgbm import LGBMClassifier
from sklearn.ensemble import StackingClassifier
from sklearn.metrics import accuracy_score, classification_report, roc_curve, auc
import matplotlib.pyplot as plt

# Read dataset
data = pd.read_csv('data_imputed.csv')
# Define category mapping
class_mapping = {
    'BENIGN': 0,
    'Brute Force': 1,
    'DDoS': 2,
    'SQL Injection': 3,
    'XSS': 4
}
# Add new integer category column
# data['attack type'] = data['attack type'].map(class_mapping)
# Selecting features & separating features and labels
X = data.drop(['attack type', 'bandwidth_utilization'], axis=1)
print(X.columns.values.tolist())
y = data['attack type']

# Split train set and test set
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Define category mapping
models = {
    'Random Forest': RandomForestClassifier(n_estimators=100, random_state=42),
    'XGBoost': XGBClassifier(n_estimators=100, random_state=42),
    'LightGBM': LGBMClassifier(n_estimators=100, random_state=42),
    'Stacking': StackingClassifier(estimators=[('rf', RandomForestClassifier(n_estimators=100, random_state=42)),
                                               ('xgb', XGBClassifier(n_estimators=100, random_state=42)),
                                               ('lgbm', LGBMClassifier(n_estimators=100, random_state=42))],
                                   final_estimator=LogisticRegression())
}

# Train & Predict
results = {}
saved_models = {}
for name, model in models.items():
    model.fit(X_train, y_train)
    saved_models[name] = model  # Save the trained model
    y_pred = model.predict(X_test)
    print('-'*40)
    print(f'Modelname: {name}')
    print(classification_report(y_test, y_pred))
    scores = cross_val_score(model, X, y, cv=10)
    print(f'Model: {name}')
    print(f'Cross-validated Scores: {scores}')
    print(f'Mean Score: {np.mean(scores):.4f}')
    print('-'*40)

# Save model
for name, model in saved_models.items():
    model_save_path = f'model/C_{name}_Model.joblib'
    joblib.dump(model, model_save_path)
    print(f"Model '{name}' saved to '{model_save_path}'")

# Train & Predict
results = {}
plt.figure(figsize=(10, 8))
colors = cycle(['aqua', 'darkorange', 'cornflowerblue', 'red', 'green'])
for name, model, color in zip(models.keys(), models.values(), colors):
    model.fit(X_train, y_train)
    y_pred_prob = model.predict_proba(X_test)
    fpr = dict()
    tpr = dict()
    roc_auc = dict()
    for i in range(len(class_mapping)):
        fpr[i], tpr[i], _ = roc_curve(y_test, y_pred_prob[:, i], pos_label=i)
        roc_auc[i] = auc(fpr[i], tpr[i])

    for i, label in enumerate(class_mapping):
        plt.plot(fpr[i], tpr[i], color=color, lw=2,
                 label=f'{name} - Class {label} (AUC = {roc_auc[i]:.2f})')

plt.plot([0, 1], [0, 1], 'k--', lw=2)
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic (ROC)')
plt.legend(loc="lower right")
plt.show()

import joblib
import pandas as pd

# Read data
new_data = pd.read_csv('data_imputed.csv')
new_data = new_data.drop(['attack type', 'bandwidth_utilization'], axis=1)
# Read models
model_path = 'model/C_Stacking_Model.joblib'
model = joblib.load(model_path)

# Carry out forecasting
new_data['attack type'] = model.predict(new_data)
print(new_data['attack type'])
# Define category mapping dictionary
class_mapping = {
    0: 'Benign',
    1: 'Brute Force',
    2: 'DDoS',
    3: 'MITM',
    4:'SQL Injection',
}

# Mapping projected results
new_data['attack type'] = new_data['attack type'].map(class_mapping)
print(new_data['attack type'])
# Generate accept/reject columns based on predictions
new_data['result'] = new_data['attack type'].apply(lambda x: 'accept' if x == 'Benign' else 'reject')

# Save to CSV
new_data.to_csv('new_data_with_predictions.csv', index=False)

print("Prediction and result columns have been added and saved to 'new_data_with_predictions.csv'.")

data = pd.read_csv('new_data_with_predictions.csv')
data